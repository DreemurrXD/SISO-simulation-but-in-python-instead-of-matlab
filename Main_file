import matplotlib.pyplot as plt
import numpy as np
import math
time_array = [0]
position_array = [0]
line = [1]
dt = 0.01
global amount_of_points
amount_of_points = 100
kd = 0
ki = 0.2
kp = 1.6
#movement damping = 1 if no damping and = 0.9 if it's 90% efficient at moveing
movement_damping = 0.99
output = 0

global goal
goal = 1
actual = 0
past_error = 0
#numberator has form [a,b,c], where numerator = a * s^2 + b * s + c. the amount of terms = highest power
#eg 2 terms means it's A * s  +  b
#same with denominator but obviously on the bottem
numerator = []
denomonator = []

def plant(numerator, denominator,error, past_error, dt):
    #numerator
    answer = 0
    for i in range (len(numerator)):
        if (i == 0):
            answer += numerator[len(numerator)-1]
        else:
            temp = 1
            for x in range(i):
                temp = temp * derivative(error, past_error, dt)
            temp = temp * numerator[len(numerator) - (i+1)]

            answer +=temp
    print(answer, "deriverative part")
    
    #denominator
    #I'm assuming I can use the derivative function and then inverse the result and multiply that to the denominator
    #Probably should check this later on
    for i in range (len(numerator)):
    if (i == 0):
        answer += numerator[len(numerator)-1]
    else:
        temp = 1
        for x in range(i):
            temp = temp * derivative(error, past_error, dt)
        temp = temp * numerator[len(numerator) - (i+1)]

            
    

def integral(error, dt):
    if (len(position_array) > 0):
        answer = 0
        for i in range (len(position_array)):
            answer += ((goal - position_array[i]) * dt)
    else:
        answer = 0
    """
    if math.fabs(answer) > goal/2:
        answer = goal/2 * (answer/math.fabs(answer))
    """
    #print(answer,"i")
    
    return answer

def derivative(error, past_error, dt):
    answer = float ((error-past_error) / dt)
    """
    if math.fabs(answer) > goal/2:
        answer = goal/2 * (answer/math.fabs(answer))
    """
    
    #print(answer, "d")
    
    return answer
print("start")
if ( ((kp * kp) - (2 * ki * kd)) > 0):
    print( float((kp * kp) - (2 * ki * kd)) )
    print("probably stable")
    
def run_simulation(goal,actual,movement_damping,kd,ki,dp,dt,time_array,position_array,line, past_error):

    for i in range (amount_of_points):
        error = goal - actual
        
        output = (kp * error) +(ki * integral(error, dt) ) +(kd * derivative(error, past_error, dt));

        actual += (output * movement_damping)
        past_error = error
        time_array.append(i*dt)
        position_array.append(actual)
        line.append(goal)

    xpoints = np.array(time_array)
    ypoints = np.array(position_array)

    plt.plot(xpoints, ypoints, xpoints, line, 'r--')
    plt.show()

    return None

run_simulation(goal,actual,movement_damping,kd,ki,kp,dt,time_array,position_array,line,past_error)

