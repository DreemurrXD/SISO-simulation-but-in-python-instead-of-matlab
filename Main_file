import matplotlib.pyplot as plt
import numpy as np
import math
time_array = [0]
position_array = [0]
line = [1]
dt = 0.01
global amount_of_points
amount_of_points = 100
#kd is derivative, ki is integral and kp is proportional control
kd = 0
ki = 0
kp = 1.4

#multiplier of the error
k = 1
#movement damping = 1 if no damping and = 0.9 if it's 90% efficient at moveing
movement_damping = 0.99
output = 0

global goal
goal = 1
actual = 0
past_error = 0
#numberator has form [a,b,c], where numerator = a * s^2 + b * s + c. the amount of terms = highest power
#eg 2 terms means it's A * s  +  b
#same with denominator but obviously on the bottem

#if there is no plant, set both num and denom as [1] 
numerator = [1]
denominator = [1,2,1]

def plant(numerator, denominator,error, past_error, dt):
    #numerator
    temp_num = 0
    for i in range (len(numerator)):
        if (i == 0):
            temp_num += numerator[len(numerator)-1]
        else:
            temp = 1
            for x in range(i):
                temp = temp * derivative(error, past_error, dt)
            temp = temp * numerator[len(numerator) - (i+1)]

            temp_num +=temp
    #print(temp_num, "numerator part")
    
    #denominator
    #I'm assuming I can use the derivative function and then inverse the result and multiply that to the denominator
    #Probably should check this later on
    temp_denom = 0
    for i in range (len(denominator)):
        if (i == 0):
            temp_denom += denominator[len(denominator)-1]
        else:
            temp = 1
            for x in range(i):
                temp = temp * derivative(error, past_error, dt)
            temp = temp * denominator[len(denominator) - (i+1)]

            temp_denom += temp
        
    #print(temp_denom, "numerator part")
    answer = float(temp_num/temp_denom)
    #print(answer,"plant")
    return answer

def integral(error, dt):
    #print(position_array)
    if (len(position_array) > 0):
        answer = 0
        for i in range (len(position_array)):
            answer += ((goal - position_array[i]) * dt)
    else:
        answer = 0
    """
    if math.fabs(answer) > goal/2:
        answer = goal/2 * (answer/math.fabs(answer))
    """
    #print(answer,"i")
    
    return answer

def derivative(error, past_error, dt):
    answer = float ((error-past_error) / dt)
    """
    if math.fabs(answer) > goal/2:
        answer = goal/2 * (answer/math.fabs(answer))
    """
    
    #print(answer, "d")
    
    return answer
print("start")
if ( ((kp * kp) - (2 * ki * kd)) > 0):
    print( float((kp * kp) - (2 * ki * kd)) )
    print("controller itelf is probably stable")
    
def run_simulation(goal,actual,movement_damping,kd,ki,dp,dt,time_array,position_array,line, past_error,numerator, denominator, k):
    
    for i in range (amount_of_points):
        error = (goal -(k * actual))
        
        output = (kp * error) +(ki * integral(error, dt) ) +(kd * derivative(error, past_error, dt));
        #if either the plant or controller is 0, it should be one 
        if (output == 0):
            output = 1
        #the plant, the mathematical representation of the thing you are moddeling
        plant_answer = plant(numerator, denominator,error, past_error, dt)

        if (plant_answer == 0):
            plant_answer = 1

        actual += (output * plant_answer* movement_damping)
        past_error = error
        time_array.append(i*dt)
        position_array.append(actual)
        line.append(goal)

    xpoints = np.array(time_array)
    ypoints = np.array(position_array)

    plt.plot(xpoints, ypoints, xpoints, line, 'r--')
    plt.show()

    return None

run_simulation(goal,actual,movement_damping,kd,ki,kp,dt,time_array,position_array,line,past_error,numerator, denominator,k )

