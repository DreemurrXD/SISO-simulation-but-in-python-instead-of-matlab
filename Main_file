import matplotlib.pyplot as plt
import numpy as np
import math
from scipy.signal import savgol_filter, butter, filtfilt
time_array = [0]
position_array = [0]
line = [1]
dt = 0.01
global amount_of_points
amount_of_points = 500
#kd is derivative, ki is integral and kp is proportional control
kd = 2
ki = 10
kp = 15

#multiplier of the error
k = 1
#movement damping = 1 if no damping and = 0.9 if it's 90% efficient at moveing
movement_damping = 0.99
output = 0

global goal
goal = 1
line = [goal]
actual = 0
past_error = 0
#numberator has form [a,b,c], where numerator = a * s^2 + b * s + c. the amount of terms = highest power
#eg 2 terms means it's A * s  +  b
#same with denominator but obviously on the bottem

#if there is no plant, set both num and denom as [1] 
numerator = [1]
denominator = [1,2,1]

def plant(numerator, denominator,error, past_error, dt):
    #numerator
    temp_num = 0
    for i in range (len(numerator)):
        if (i == 0):
            temp_num += numerator[len(numerator)-1]
        else:
            temp = 1
            for x in range(i):
                temp = temp * derivative(error, past_error, dt)
            temp = temp * numerator[len(numerator) - (i+1)]

            temp_num +=temp
    #print(temp_num, "numerator part")
    
    #denominator
    #I'm assuming I can use the derivative function and then inverse the result and multiply that to the denominator
    #Probably should check this later on
    temp_denom = 0
    for i in range (len(denominator)):
        if (i == 0):
            temp_denom += denominator[len(denominator)-1]
        else:
            temp = 1
            for x in range(i):
                temp = temp * derivative(error, past_error, dt)
            temp = temp * denominator[len(denominator) - (i+1)]

            temp_denom += temp
        
    #print(temp_denom, "numerator part")
    answer = float(temp_num/temp_denom)
    #print(answer,"plant")
    return answer

def butter_lowpass_filter(position_array,cutoff, fs, order):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    # Get the filter coefficients 
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    y = filtfilt(b, a, position_array)
    return y


def integral(error, dt):
    #print(position_array)
    if (len(position_array) > 0):
        answer = 0
        for i in range (len(position_array)):
            answer += ((goal - position_array[i]) * dt)
    else:
        answer = 0

    #this term is here to avoid integral wind up, or at least lower it's effect
    answer = answer * error
    """
    if math.fabs(answer) > goal/2:
        answer = goal/2 * (answer/math.fabs(answer))
    """
    #print(answer,"i")
    
    return answer

def derivative(error, past_error, dt):
    answer = float ((error-past_error) / dt)
    """
    if math.fabs(answer) > goal/2:
        answer = goal/2 * (answer/math.fabs(answer))
    """
    
    #print(answer, "d")
    
    return answer
print("start")
if ( ((kp * kp) - (2 * ki * kd)) > 0):
    print( float((kp * kp) - (2 * ki * kd)) )
    print("controller itelf is probably stable")
    
def run_simulation(goal,actual,movement_damping,kd,ki,dp,dt,time_array,position_array,line, past_error,numerator, denominator, k):
    
    for i in range (amount_of_points):
        error = (goal -(k * actual))
        
        output = (kp * error) +(ki * integral(error, dt) ) +(kd * derivative(error, past_error, dt));
        #if either the plant or controller is 0, it should be one 
        if (output == 0):
            output = 1
        #the plant, the mathematical representation of the thing you are moddeling
        plant_answer = plant(numerator, denominator,error, past_error, dt)

        if (plant_answer == 0):
            plant_answer = 1

        actual += (output * plant_answer* movement_damping * dt)
        past_error = error
        time_array.append(i*dt)
        position_array.append(actual)
        line.append(goal)

        if (math.fabs(actual) > 100*goal):
            break
    xpoints = np.array(time_array)
    ypoints = np.array(position_array)

    #this is here if the simulation leaves reasonable bounds before it should
    #the filter requires 50 data points and throws an error if it's given less
    #this populates the postion_array with 50 of the last datapoint
    #print(xpoints)
    #print(ypoints)
    """
    if (len(position_array) >= 50):
        #print(len(position_array))
        print("savgol filter has enough data points")
    else:
        print("savgol filter doesn't have enough points")
        temp = 0
        temp = position_array[len(position_array)-1]
        time_temp = time_array[len(time_array)-1]
        x=1
        for i in range(50):
            position_array.append(temp)
            time_array.append(time_temp + (x * dt))
            line.append(goal)
            x+=1
    """        
    xpoints = np.array(time_array)

    cutoff = 25
    fs = 100
    order = 12
    ypoints_filtered = np.array(butter_lowpass_filter(position_array,cutoff, fs, order))
    #ypoints_filtered = savgol_filter(np.array(position_array),50,10)    
            
            
            
    print(xpoints)
    print(ypoints)
    print(len(line))
    plt.plot(xpoints, ypoints, "orange",xpoints, ypoints_filtered,"deepskyblue", xpoints, line, 'r--')
    plt.show()

    return None

run_simulation(goal,actual,movement_damping,kd,ki,kp,dt,time_array,position_array,line,past_error,numerator, denominator,k )

