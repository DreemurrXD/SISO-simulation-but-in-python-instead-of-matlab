import matplotlib.pyplot as plt
import numpy as np
import math
from math import e
from scipy.signal import butter, filtfilt
time_array = [0]
position_array = [0]
line = [1]
dt = 0.001
global amount_of_points
amount_of_points = 10000
#kd is derivative, ki is integral and kp is proportional control
kd = 0
ki = 0
kp = 0

#multiplier of the plant, unity feedback
k = 1000
#movement damping = 1 if no damping and = 0.9 if it's 90% efficient at moving
movement_damping = 0.99
output = 0

global goal
goal = 1
line = [goal]
actual = 0
past_error = 0
#numberator has form [a,b,c], where numerator = a * s^2 + b * s + c. the amount of terms = highest power
#eg 2 terms means it's A * s  +  b
#same with denominator but obviously on the bottem

#if there is no plant, set both num and denom as [1] 
numerator = [1,1]
denominator = [1,-50]
print(e)

def plant(numerator, denominator,k,simulation_time):
    coeff = []
    diff = len(denominator) - len(numerator)
    for i in range(len(denominator)):
        if ((i-diff)>= 0):
            coeff.append(denominator[i] + k * numerator[i-diff])
        else:
            coeff.append(denominator[i])
    #print(coeff)

    roots = np.roots(coeff)

    #print(roots)
    #print(len(roots))
    answer = 0
    for i in range(len(roots)):
        temp = 0
        if (roots[i].real != 0):
            temp = pow(e, (roots[i].real * simulation_time))
            #print(temp, "real")
        else:
            temp = 1
        
        if (roots[i].imag != 0):
            temp = temp * math.cos(roots[i].imag * simulation_time)
            #print(temp, "real * imaginary")
        else:
            temp = temp * 1
        
        answer = answer + temp
    
    #print(answer)
    return answer

    
        
    


def butter_lowpass_filter(position_array,cutoff, fs, order):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    # Get the filter coefficients 
    b, a = butter(order, normal_cutoff, btype='low', analog=False)
    y = filtfilt(b, a, position_array)
    return y


def integral(error, dt):
    #print(position_array)
    if (len(position_array) > 0):
        answer = 0
        for i in range (len(position_array)):
            answer += ((goal - position_array[i]) * dt)
    else:
        answer = 0

    #this term is here to avoid integral wind up, or at least lower it's effect
    answer = answer * error
    """
    if math.fabs(answer) > goal/2:
        answer = goal/2 * (answer/math.fabs(answer))
    """
    #print(answer,"i")
    
    return answer

def derivative(error, past_error, dt):
    answer = float ((error-past_error) / dt)
    """
    if math.fabs(answer) > goal/2:
        answer = goal/2 * (answer/math.fabs(answer))
    """
    
    #print(answer, "d")
    
    return answer
print("start")
if ( ((kp * kp) - (2 * ki * kd)) > 0):
    print( float((kp * kp) - (2 * ki * kd)) )
    print("controller itelf is probably stable")
    
def run_simulation(goal,actual,movement_damping,kd,ki,dp,dt,time_array,position_array,line, past_error,numerator, denominator, k):
    
    for i in range (amount_of_points):
        error = (goal - actual)
        simulation_time = i * dt
        #print(i)
        if (i % 5 == 0):
            output = (kp * error) +(ki * integral(error, dt) ) +(kd * derivative(error, past_error, dt));
            #print("yay",i)
        else:
            output = 1
        #if either the plant or controller is 0, it should be one 
        if (output == 0):
            output = 1
            
        #the plant, the mathematical representation of the thing you are moddeling
        plant_answer = plant(numerator, denominator,k,simulation_time)
        """
        if (plant_answer == 0):
            plant_answer = 1
        """   

        actual = goal -(output * plant_answer* movement_damping * goal)
        """
        print(output, "output")
        print(error, "error")
        print(actual,"actual")
        """
        #making sure it doesn't grow exponenitally too long
        if (abs(actual) > 100 * goal):
            print(actual, "maybe we stop here")
            break
        #end the graph if it's stable for long enough
        temp = 0
        if (len(position_array) > 200):
            for j in range (100):
                if (position_array[len(position_array)-(j+1)] != goal):
                    temp = 1
        if (temp == 0) and (len(position_array) > 200):
            print("should be stable")
            break
                
        past_error = error
        time_array.append(i*dt)
        position_array.append(actual)
        line.append(goal)
        


    if (len(position_array) >= 50):
        #print(len(position_array))
        print("filter has enough data points")
    else:
        print("filter doesn't have enough points")
        temp = 0
        temp = position_array[len(position_array)-1]
        time_temp = time_array[len(time_array)-1]
        x=1
        for i in range(50):
            position_array.append(temp)
            time_array.append(time_temp + (x * dt))
            line.append(goal)
            x+=1
    xpoints = np.array(time_array)
    ypoints = np.array(position_array)     


      
    xpoints = np.array(time_array)

    cutoff = 25
    fs = 100
    order = 12
    print(len(position_array),"length of position array")
    """
    plt.plot(xpoints, ypoints)
    plt.show()
    """
    ypoints_filtered = np.array(butter_lowpass_filter(position_array,cutoff, fs, order))
     
            
            
            
    #print(len(xpoints), xpoints,"xpoints")
    #print(len(ypoints), ypoints, "ypoints")
    print(len(xpoints))
    print(len(ypoints))
    print(len(line))
    
    #plt.plot(xpoints, ypoints, "orange",xpoints, ypoints_filtered,"deepskyblue", xpoints, line, 'r--')
    plt.plot(xpoints, ypoints, "orange", xpoints, line, 'r--')
    plt.show()

    return None

run_simulation(goal,actual,movement_damping,kd,ki,kp,dt,time_array,position_array,line,past_error,numerator, denominator,k )

